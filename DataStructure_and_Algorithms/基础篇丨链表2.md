### 1如何轻松写出正确的链表代码

#### 1.1技巧一：理解指针或引用的含义
- 不管是指针还是引用，意思都是一样的：存储所指对象的内存地址。
- 理解：将某个变量赋值给指针，实际上就是将这个变量的地址赋值给指针，或者说，这个指针中存储了这个变量的内存地址，通过访问这个内存地址就能找到这个变量。
```java
p->next=q
//p结点的next指针存储了q结点的内存地址

p->next=p->next->next
//p结点的next指针存储了p结点的下下一个结点的内存地址。
//（p结点的next指向下一个结点的next，下一个结点的next存储的是下下一个结点的内存地址）
```

#### 1.2技巧二：警惕指针丢失和内存泄漏
![avatar](../images/插入结点.jpg)
```java
//我们希望在结点a和结点b之间插入结点x，假设当前指针p指向结点a。则正确的做法是：
x->next=b;
a->next=x;
// 错误的做法：
p->next=x;
x->next=p->next;//此时p->next指针已经指向结点x了，所以这一句是自己指向自己，造成后面的结点无法访问，丢失指针，导致内存泄漏
```
- 删除链表结点时，一定要手动释放内存空间。否则也会出现内存泄漏的问题。（对java这种虚拟机自动管理内存的编程语言来说，就不需要考虑这么多）

#### 1.3技巧三：利用哨兵简化实现难度
- 在结点p后面插入一个新的结点，只需两行代码：
```java
new_node->next = p->next;
p->next = new_node;
```
- 当我们向一个空链表中插入第一个结点，需要进行特殊处理：
```java
if (head == null) {
    head = new_node;
}
```
- 单链表结点删除操作，如果要删除结点p的后继结点，只需要一行代码：
```java
p->next = p->next->next;
```
- 如果我们要删除链表中最后一个结点，也需要特殊处理：
```java
if (head->next == null) {
    head = null;
}
```
- 上述第一个、最后一个结点需要特殊处理，实现起来较为繁琐，不简洁。因此，用“哨兵”解决“边界问题”，不直接参与业务逻辑。

- 如何表示一个空链表：`head=null`表示链表中没有结点了。head表示头结点指针，指向链表中的第一个结点。

- 如果引入哨兵结点，则在任何时候，不管链表是不是空。head指针都会一直指向哨兵结点。这种有哨兵结点的链表叫“带头链表”，相反，没有的就叫“不带头链表”
![avatar](../images/带头链表.jpg)

- 哨兵结点不存储数据，因为哨兵结点一直存在，所以插入第一个结点和插入其他结点，删除最后一个结点和删除其他结点，都可以统一为相同的代码实现逻辑。

- 这种技巧在插入排序、归并排序、动态规划中都有用到。

#### 1.4技巧四：重点留意边界条件处理
- 软件开发在一些边界或者异常情况下，最容易产生bug。要实现没有 Bug 的链表代码，一定要在编写的过程中以及编写完成之后，检查边界条件是否考虑全面，以及代码在边界条件下是否能正确运行。
- 检查链表代码是否正确的边界条件有：
    1. 如果链表为空时，代码是否能正常工作？
    2. 如果链表只包含一个结点时，代码是否能正常工作？
    3. 如果链表只包含两个结点时，代码是否能正常工作？
    4. 代码逻辑在处理头结点和尾结点的时候，是否能正常工作？
- 写代码的时候一定要多想想，代码在运行的时候，可能会遇到哪些边界情况或者异常情况，遇到了应该如何面对。

#### 1.5举例画图，辅助思考
![avatar](../images/链表画图辅助.jpg)

#### 1.6多写多练，没有捷径
- 5个常见的链表操作：
    1. 单链表反转
    2. 链表中环的检测
    3. 两个有序的链表合并
    4. 删除链表倒数第n个结点
    5. 求链表的中间结点

### 2.内容小结
- 这节主要讲了写出正确链表代码的六个技巧。分别是理解指针或引用的含义、警惕指针丢失和内存泄漏、利用哨兵简化实现难度、重点留意边界条件处理，以及举例画图、辅助思考，还有多写多练。

- 写链表代码是最考验逻辑思维能力的。因为，链表代码到处都是指针的操作、边界条件的处理，稍有不慎就容易产生 Bug。

- 链表代码写得好坏，可以看出一个人写代码是否够细心，考虑问题是否全面，思维是否缜密。所以，这也是很多面试官喜欢让人手写链表代码的原因。所以，这一节讲到的东西，你一定要自己写代码实现一下，才有效果。
